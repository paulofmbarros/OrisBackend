name: AI Agent - Revise Plan

on:
  issue_comment:
    types: [created]

jobs:
  revise:
    if: contains(github.event.comment.body, '/revise')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
      checks: write
      actions: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Extract revision feedback
        id: extract_revision
        env:
          COMMENT_BODY_VAL: ${{ github.event.comment.body }}
          ISSUE_NUMBER_VAL: ${{ github.event.issue.number }}
          PR_NUMBER_VAL: ${{ github.event.pull_request.number }}
        run: |
          COMMENT_BODY="$COMMENT_BODY_VAL"
          REVISION_FEEDBACK=$(echo "$COMMENT_BODY" | sed -E 's|^\s*/revise\s+||')
          
          if [ -z "$REVISION_FEEDBACK" ]; then
            echo "Error: No revision feedback provided. Please include feedback after /revise"
            echo "Example: /revise Please use a different authentication approach"
            exit 1
          fi
          
          echo "REVISION_FEEDBACK<<EOF" >> $GITHUB_OUTPUT
          echo "$REVISION_FEEDBACK" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          # Use either issue number or PR number
          ISSUE_NUMBER="$ISSUE_NUMBER_VAL"
          if [ -z "$ISSUE_NUMBER" ]; then
            ISSUE_NUMBER="$PR_NUMBER_VAL"
          fi
          echo "ISSUE_NUMBER=$ISSUE_NUMBER" >> $GITHUB_OUTPUT

      - name: Find original plan
        id: find_plan
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = parseInt('${{ steps.extract_revision.outputs.ISSUE_NUMBER }}');
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
            });
            
            // Find the most recent plan comment
            let planRunId = null;
            let originalPrompt = null;
            let jiraTicket = null;
            
            for (const comment of comments.data.reverse()) {
              const runIdMatch = comment.body.match(/Agent Plan Run ID: (\d+)/);
              if (runIdMatch && comment.body.includes('AI Agent Plan')) {
                planRunId = runIdMatch[1];
                break;
              }
            }
            
            if (!planRunId) {
              core.setFailed('Could not find original plan. Please ensure a plan was generated first.');
              return;
            }
            
            // Try to download the original plan artifact
            try {
              const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
                owner: context.repo.owner,
                repo: context.repo.repo,
                run_id: parseInt(planRunId),
              });
            
              const planArtifact = artifacts.data.artifacts.find(a => a.name === 'agent-plan');
              if (planArtifact) {
                const download = await github.rest.actions.downloadArtifact({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  artifact_id: planArtifact.id,
                  archive_format: 'zip',
                });
            
                const fs = require('fs');
                const { execSync } = require('child_process');
            
                fs.mkdirSync('original-plan', { recursive: true });
                fs.writeFileSync('original-plan.zip', Buffer.from(download.data));
                execSync('unzip -q original-plan.zip -d original-plan/');
            
                if (fs.existsSync('original-plan/prompt.txt')) {
                  originalPrompt = fs.readFileSync('original-plan/prompt.txt', 'utf8').trim();
                }
                
                if (fs.existsSync('original-plan/jira_ticket.txt')) {
                  jiraTicket = fs.readFileSync('original-plan/jira_ticket.txt', 'utf8').trim();
                }
            
                execSync('rm -rf original-plan original-plan.zip');
              }
            } catch (error) {
              core.warning(`Could not download original plan: ${error.message}`);
            }
            
            // Fallback: try to extract from issue/PR title
            if (!originalPrompt) {
              try {
                const issue = await github.rest.issues.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issueNumber,
                });
            
                const title = issue.data.title || '';
                const body = issue.data.body || '';
                const jiraMatch = (title + ' ' + body).match(/([A-Z]+-[0-9]+)/);
            
                if (jiraMatch) {
                  originalPrompt = `Work on Jira ticket ${jiraMatch[1]}`;
                  if (!jiraTicket) jiraTicket = jiraMatch[1];
                } else {
                  originalPrompt = 'Work on the requested task';
                }
              } catch (error) {
                originalPrompt = 'Work on the requested task';
              }
            }
            
            core.setOutput('plan_run_id', planRunId);
            core.setOutput('original_prompt', originalPrompt || 'Work on the requested task');
            core.setOutput('jira_ticket', jiraTicket || '');

      - name: Download original plan artifact
        uses: dawidd6/action-download-artifact@v3
        with:
          name: agent-plan
          path: original-plan/
          github_token: ${{ secrets.GITHUB_TOKEN }}
          run_id: ${{ steps.find_plan.outputs.plan_run_id }}
          if_no_artifact_found: warn
          workflow: agent-plan.yml

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Gemini CLI
        run: npm install -g @google/gemini-cli

      - name: Configure MCP Servers
        run: |
          mkdir -p ~/.gemini
          
          # Use Node.js to generate proper JSON
          node << 'EOF'
          const fs = require('fs');
          const mcpServers = {};
          
          // Add Notion MCP (required for contract)
          if (process.env.NOTION_API_KEY) {
            mcpServers.notion = {
              command: "npx",
              args: ["-y", "@modelcontextprotocol/server-notion"],
              env: {
                NOTION_API_KEY: process.env.NOTION_API_KEY
              }
            };
          }
          
          // Add Atlassian Rovo MCP (optional)
          if (process.env.ATLASSIAN_MCP_URL) {
            mcpServers["atlassian-rovo-mcp-server"] = {
              url: process.env.ATLASSIAN_MCP_URL,
              auth: {
                type: "oauth2",
                clientId: process.env.ATLASSIAN_MCP_CLIENT_ID,
                clientSecret: process.env.ATLASSIAN_MCP_CLIENT_SECRET
              }
            };
          }
          
          const config = {
            mcpServers: mcpServers
          };
          
          fs.writeFileSync(
            process.env.HOME + '/.gemini/settings.json',
            JSON.stringify(config, null, 2)
          );
          
          console.log('MCP servers configured:');
          console.log(JSON.stringify(config, null, 2));
          EOF
        env:
          NOTION_API_KEY: ${{ secrets.NOTION_API_KEY }}
          ATLASSIAN_MCP_URL: ${{ secrets.ATLASSIAN_MCP_URL }}
          ATLASSIAN_MCP_CLIENT_ID: ${{ secrets.ATLASSIAN_MCP_CLIENT_ID }}
          ATLASSIAN_MCP_CLIENT_SECRET: ${{ secrets.ATLASSIAN_MCP_CLIENT_SECRET }}

      - name: Setup environment
        run: |
          chmod +x scripts/agent.sh
          chmod +x scripts/runtimes/*.sh

      - name: Run agent with revision
        id: agent_revision
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ORIGINAL_PROMPT: ${{ steps.find_plan.outputs.original_prompt }}
          REVISION_FEEDBACK: ${{ steps.extract_revision.outputs.REVISION_FEEDBACK }}
          JIRA_TICKET: ${{ steps.find_plan.outputs.jira_ticket }}
        run: |
          set +e
          
          OUTPUT_FILE=$(mktemp)
          ERROR_FILE=$(mktemp)
          
          # Build enhanced prompt with revision feedback
          ENHANCED_PROMPT="$ORIGINAL_PROMPT"$'\n\n'"REVISION REQUEST:"$'\n'"The previous plan needs to be revised based on the following feedback:"$'\n'"$REVISION_FEEDBACK"$'\n\n'"Please generate a revised plan that addresses this feedback while maintaining alignment with the original requirements."
          
          # Run agent
          ./scripts/agent.sh \
            --runtime gemini \
            --role backend \
            "$ENHANCED_PROMPT" \
            > "$OUTPUT_FILE" 2> "$ERROR_FILE"
          
          EXIT_CODE=$?
          
          # Save outputs
          echo "PLAN_OUTPUT<<EOF" >> $GITHUB_OUTPUT
          cat "$OUTPUT_FILE" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "EXIT_CODE=$EXIT_CODE" >> $GITHUB_OUTPUT
          
          # Save to artifact
          mkdir -p plan-artifact
          cp "$OUTPUT_FILE" plan-artifact/plan-output.txt
          cp "$ERROR_FILE" plan-artifact/plan-error.txt
          echo "$ENHANCED_PROMPT" > plan-artifact/prompt.txt
          echo "backend" > plan-artifact/role.txt
          echo "gemini" > plan-artifact/runtime.txt
          echo "true" > plan-artifact/is-revision.txt
          echo "$REVISION_FEEDBACK" > plan-artifact/revision-feedback.txt
          echo "$JIRA_TICKET" > plan-artifact/jira_ticket.txt
          
          rm -f "$OUTPUT_FILE" "$ERROR_FILE"
          
          # Re-enable exit on error and fail if there were errors
          set -e
          
          # Check for errors and fail if any
          if [ $EXIT_CODE -ne 0 ]; then
            echo "‚ùå Agent revision phase failed with exit code: $EXIT_CODE"
            if [ -s plan-artifact/plan-error.txt ]; then
              echo "Error output:"
              cat plan-artifact/plan-error.txt
            fi
            exit $EXIT_CODE
          fi
          
          # Also check if error file has content (even if exit code was 0)
          if [ -s plan-artifact/plan-error.txt ]; then
            ERROR_CONTENT=$(cat plan-artifact/plan-error.txt)
            # Check for common error patterns
            if echo "$ERROR_CONTENT" | grep -qiE "(error|failed|exception|command not found|permission denied|not found)"; then
              echo "‚ùå Errors detected in plan revision:"
              echo "$ERROR_CONTENT"
              exit 1
            fi
          fi

      - name: Display revised plan output
        if: steps.agent_revision.outputs.PLAN_OUTPUT != ''
        run: |
          echo "## üîÑ AI Agent Revised Plan Output" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat plan-artifact/plan-output.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          
          echo "=== Revised Plan Output ==="
          cat plan-artifact/plan-output.txt

      - name: Upload revised plan artifact
        uses: actions/upload-artifact@v6
        with:
          name: agent-plan
          path: plan-artifact/
          retention-days: 7

      - name: Post revised plan as comment
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = parseInt('${{ steps.extract_revision.outputs.ISSUE_NUMBER }}');
            const planOutput = `${{ steps.agent_revision.outputs.PLAN_OUTPUT }}`;
            const revisionFeedback = `${{ steps.extract_revision.outputs.REVISION_FEEDBACK }}`;
            
            const body = `## üîÑ AI Agent Plan (Revised)
            
            > **Revision Feedback:** ${revisionFeedback}
            
            ${planOutput}
            
            ---
            
            ### ‚ö†Ô∏è Review Required
            
            **Options:**
            1. ‚úÖ **Approve and proceed**: Click the "Review deployments" button below and approve, or comment: \`/proceed\`
            2. üîÑ **Request more changes**: Comment: \`/revise <your feedback here>\` to modify the plan again
            3. ‚ùå **Cancel**: Close this issue/PR
            
            <!-- Agent Plan Run ID: ${process.env.GITHUB_RUN_ID} -->`;
            
            github.rest.issues.createComment({
              issue_number: issueNumber,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });